<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Java/开发框架和工具/dwr使用js调用java方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/18/Java/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%92%8C%E5%B7%A5%E5%85%B7/dwr%E4%BD%BF%E7%94%A8js%E8%B0%83%E7%94%A8java%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-01-18T11:01:37.397Z" itemprop="datePublished">2021-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="DWR（Direct-Web-Remoting）"><a href="#DWR（Direct-Web-Remoting）" class="headerlink" title="DWR（Direct Web Remoting）"></a>DWR（Direct Web Remoting）</h4><p>是一个用于改善web页面与Java类交互的远程服务器端Ajax开源框架,可以帮助开发人员开发包含AJAX技术的网站.它可以允许在浏览器里的代码使用运行在WEB服务器上的JAVA函数,就像它就在浏览器里一样。</p>
<p>DWR（Direct Web Remoting）是一个用于改善web页面与Java类交互的远程服务器端Ajax开源框架,可以帮助开发人员开发包含AJAX技术的网站.它可以允许在浏览器里的代码使用运行在WEB服务器上的JAVA函数,就像它就在浏览器里一样。</p>
<h4 id="Dwr调用方法"><a href="#Dwr调用方法" class="headerlink" title="Dwr调用方法"></a>Dwr调用方法</h4><p>普通ajax调用方法如下：<br><img src="https://img-blog.csdn.net/20151211110449600" alt="这里写图片描述"></p>
<p>Flex:用于flash编程，实现页面/视图层的开发 ，开发出的效果和网页样式不一样，更接近windows桌面的样式，开发的成果就是一个flash文件。<br>Flex实现了视图层：<br><img src="https://img-blog.csdn.net/20151211110459453" alt="这里写图片描述"></p>
<h4 id="Dwr的配置"><a href="#Dwr的配置" class="headerlink" title="Dwr的配置"></a>Dwr的配置</h4><h5 id="Jar包："><a href="#Jar包：" class="headerlink" title="Jar包："></a>Jar包：</h5><p>如果是maven工程加入以下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- dwr --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.directwebremoting&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dwr&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.M1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>
<p>如果不是maven工程则需要加入; dwr-3.0.M1.jar</p>
<h5 id="Dwr-servlet"><a href="#Dwr-servlet" class="headerlink" title="Dwr servlet"></a>Dwr servlet</h5><p>在web.xml中加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;   </span><br><span class="line">  &lt;servlet-name&gt;dwr-invoker&lt;&#x2F;servlet-name&gt;   </span><br><span class="line">  &lt;servlet-class&gt;uk.ltd.getahead.dwr.DWRServlet&lt;&#x2F;servlet-class&gt;   </span><br><span class="line">  &lt;!-- 是否允许调试，如果要在浏览器中调试则必须设置为true --&gt; </span><br><span class="line">  &lt;init-param&gt;   </span><br><span class="line">   &lt;param-name&gt;debug&lt;&#x2F;param-name&gt;   </span><br><span class="line">   &lt;param-value&gt;true&lt;&#x2F;param-value&gt;   </span><br><span class="line">  &lt;&#x2F;init-param&gt;   </span><br><span class="line">  &lt;!-- 如果允许跨域请求，则必须将此值设置为false，默认值为true --&gt; </span><br><span class="line">   &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;crossDomainSessionSecurity&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;false&lt;&#x2F;param-value&gt;</span><br><span class="line">     &lt;&#x2F;init-param&gt;</span><br><span class="line">     &lt;init-param&gt;</span><br><span class="line">           &lt;param-name&gt;allowScriptTagRemoting&lt;&#x2F;param-name&gt;</span><br><span class="line">           &lt;param-value&gt;true&lt;&#x2F;param-value&gt;</span><br><span class="line">     &lt;&#x2F;init-param&gt;</span><br><span class="line"> &lt;&#x2F;servlet&gt;   </span><br><span class="line"> &lt;servlet-mapping&gt;   </span><br><span class="line">  &lt;servlet-name&gt;dwr-invoker&lt;&#x2F;servlet-name&gt;   </span><br><span class="line">  &lt;url-pattern&gt;&#x2F;dwr&#x2F;*&lt;&#x2F;url-pattern&gt;   </span><br><span class="line"> &lt;&#x2F;servlet-mapping&gt;   12345678910111213141516171819202122</span><br></pre></td></tr></table></figure>
<h5 id="访问-dwr-交给dwr来处理。"><a href="#访问-dwr-交给dwr来处理。" class="headerlink" title="访问/dwr/交给dwr来处理。"></a>访问/dwr/交给dwr来处理。</h5><p>在WEB-INF下配置dwr.xml文件：<br>配置dwr服务端哪些方法允许页面ajax调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE dwr PUBLIC &quot;-&#x2F;&#x2F;GetAhead Limited&#x2F;&#x2F;DTD Direct Web Remoting 2.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;getahead.ltd.uk&#x2F;dwr&#x2F;dwr30.dtd&quot;&gt;</span><br><span class="line">&lt;dwr&gt;</span><br><span class="line">  &lt;allow&gt;</span><br><span class="line">    &lt;create creator&#x3D;&quot;spring&quot; javascript&#x3D;&quot;dwrService&quot;&gt;</span><br><span class="line">      &lt;param name&#x3D;&quot;beanName&quot; value&#x3D;&quot;dwrService&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;create&gt;</span><br><span class="line">  &lt;&#x2F;allow&gt;</span><br><span class="line">&lt;&#x2F;dwr&gt;</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>
<p>javascript=”dwrService”:<br>如果要调用dwr.xml配置的service(这里配置是名称为：dwrService的bean)的方法，需要在页面中引入dwrService.js<br>Js是地址是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&#39;text&#x2F;javascript&#39; src&#x3D;&#39;工程路径&#x2F;dwr&#x2F;interface&#x2F; dwrService.js&#39;&gt;&lt;&#x2F;script&gt;1</span><br></pre></td></tr></table></figure>
<p>/dwr/interface/ dwrService.js交给dwr的servlet进行处理，servlet会根据dwr.xml中配置，生成一个js文件的内容。<br><code>&lt;param name=&quot;beanName&quot; value=&quot;dwrService&quot; /&gt;</code>：<br>Spring容器中名称为：dwrService的bean</p>
<h5 id="Dwr测试"><a href="#Dwr测试" class="headerlink" title="Dwr测试"></a><strong>Dwr测试</strong></h5><p>调用yycg.base.service.impl.DwrServiceImpl里边的方法。<br>由于yycg.base.service.impl.DwrServiceImpl使用spring管理，在spring容器中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- dwrService --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;dwrService&quot; class&#x3D;&quot;yycg.base.service.impl.DwrServiceImpl&quot;&#x2F;&gt;12</span><br></pre></td></tr></table></figure>
<p>在页面中加入dwrService的js引用，可以调用上边dwrService这个bean中的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&#39;text&#x2F;javascript&#39; src&#x3D;&#39;工程路径&#x2F;dwr&#x2F;interface&#x2F; dwrService.js&#39;&gt;&lt;&#x2F;script&gt;1</span><br></pre></td></tr></table></figure>
<p>如果要调用其它bean的方法，还引入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&#39;text&#x2F;javascript&#39; src&#x3D;&#39;工程路径&#x2F;dwr&#x2F;interface&#x2F; XXXXXXXX.js&#39;&gt;&lt;&#x2F;script&gt;1</span><br></pre></td></tr></table></figure>
<p>都 必须引用dwr的引擎配置js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&#39;text&#x2F;javascript&#39; src&#x3D;&#39;$&#123;baseurl&#125;dwr&#x2F;engine.js&#39;&gt;&lt;&#x2F;script&gt;   </span><br><span class="line">&lt;script type&#x3D;&#39;text&#x2F;javascript&#39; src&#x3D;&#39;$&#123;baseurl&#125;dwr&#x2F;util.js&#39;&gt;&lt;&#x2F;script&gt;  </span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&#39;text&#x2F;javascript&#39; src&#x3D;&#39;$&#123;baseurl&#125;dwr&#x2F;engine.js&#39;&gt;&lt;&#x2F;script&gt;   </span><br><span class="line">&lt;script type&#x3D;&#39;text&#x2F;javascript&#39; src&#x3D;&#39;$&#123;baseurl&#125;dwr&#x2F;util.js&#39;&gt;&lt;&#x2F;script&gt;  </span><br><span class="line">&lt;script type&#x3D;&#39;text&#x2F;javascript&#39; src&#x3D;&#39;$&#123;baseurl&#125;dwr&#x2F;interface&#x2F;dwrService.js&#39;&gt;&lt;&#x2F;script&gt;123456</span><br></pre></td></tr></table></figure>
<h5 id="测试如下："><a href="#测试如下：" class="headerlink" title="测试如下："></a>测试如下：</h5><p>调用无参数方法：<br>//dwrService是加载js的名称<br>//testdwr是dwrService对应的bean的方法名<br>//callback：回调方法<br>dwrService.testdwr({<br>callback:function(data) {<br>alert(data);<br>}});</p>
<p>调用有参数方法：</p>
<p>dwrService.testdwr2(‘张三’,{<br>callback:function(data) {<br>alert(data);<br>}});</p>
<h4 id="Dwr在本系统的应用"><a href="#Dwr在本系统的应用" class="headerlink" title="Dwr在本系统的应用"></a>Dwr在本系统的应用</h4><h5 id="1、-在年份下框显示数据，通过dwr来获取"><a href="#1、-在年份下框显示数据，通过dwr来获取" class="headerlink" title="1、 在年份下框显示数据，通过dwr来获取"></a>1、 在年份下框显示数据，通过dwr来获取</h5><p>需求，显示近6年的年份。<br>需要在dwrService写一个方法：<br>获取近6年的年份<br>客户端通过dwr调用该方法，得到近6年的年份，在页面向年份下拉框设置6年的年份。<br>如果通过dwr方法，在action方法无需调用service获取数据，通过model传到页面。<br><img src="https://img-blog.csdn.net/20151211110819543" alt="这里写图片描述"></p>
<p>客户端调用上边的方法，将list转成json在客户端解析。</p>
<h5 id="2、-在所有数据字典下拉框-通过dwr来获取数据字典信息"><a href="#2、-在所有数据字典下拉框-通过dwr来获取数据字典信息" class="headerlink" title="2、 在所有数据字典下拉框, 通过dwr来获取数据字典信息"></a>2、 在所有数据字典下拉框, 通过dwr来获取数据字典信息</h5><p>针对业务代码：<br>编写根据typecode获取业务代码及代码对应的名称<br><img src="https://img-blog.csdn.net/20151211110837923" alt="这里写图片描述"></p>
<p>客户端使用固定的三个js方法，解析上边三个方法返回数据，解析完数据，将数据填充到select下拉框。</p>
<p><img src="https://img-blog.csdn.net/20151211110847294" alt="这里写图片描述"></p>
<h4 id="Dwr提供方法调用java的注解详解"><a href="#Dwr提供方法调用java的注解详解" class="headerlink" title="Dwr提供方法调用java的注解详解"></a>Dwr提供方法调用java的注解详解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">DWR提供的注解类型 —<span class="meta">@RemoteProxy</span>、<span class="meta">@RemoteMethod</span>、<span class="meta">@DataTransferObject</span>和...</span><br><span class="line">经常用到的注解主要有：<span class="meta">@RemoteProxy</span>、<span class="meta">@RemoteMethod</span>、<span class="meta">@DataTransferObject</span>和<span class="meta">@RemoteProperty</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="meta">@RemoteProxy</span>和<span class="meta">@RemoteMethod</span></span><br><span class="line"><span class="meta">@RemoteMethod</span>对应于原来dwr.xml文件中的create标签，用于创建DWR所提供的远程方法；而<span class="meta">@RemoteMethod</span>对应于create标签中的 &lt;include method=”<span class="string">&quot;/&gt;，用来指定所要暴露的方法名称。我们举例来说明：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@RemoteProxy(name=&quot;</span>bankFunctions<span class="string">&quot;)</span></span><br><span class="line"><span class="string">public class Bank &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @RemoteMethod</span></span><br><span class="line"><span class="string">    public void buy() &#123;</span></span><br><span class="line"><span class="string">        // ...</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">从上面可以看出，@RemoteProxy表示这个类将用于远程方法，而使用@RemoteMethod指定所要暴露的方法，没有使用@RemoteMethod的方法将不会显示在客户端。</span></span><br><span class="line"><span class="string">上面的注释使用dwr.xml表示如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!DOCTYPE dwr PUBLIC</span></span><br><span class="line"><span class="string">    &quot;</span>-<span class="comment">//GetAhead Limited//DTD Direct Web Remoting 2.0//EN&quot;</span></span><br><span class="line">    <span class="string">&quot;http://getahead.ltd.uk/dwr/dwr20.dtd&quot;</span>&gt;</span><br><span class="line">&lt;dwr&gt;</span><br><span class="line">    &lt;allow&gt;</span><br><span class="line">        &lt;create creator=<span class="string">&quot;new&quot;</span> javascript=<span class="string">&quot;bankFunctions&quot;</span>&gt;</span><br><span class="line">            &lt;include method=<span class="string">&quot;buy&quot;</span> /&gt;</span><br><span class="line">        &lt;/create&gt;</span><br><span class="line">    &lt;/allow&gt;</span><br><span class="line">&lt;/dwr&gt;</span><br><span class="line">如果使用Spring中的DAO活逻辑层则需要进行如下的设置：</span><br><span class="line"></span><br><span class="line"><span class="comment">// BookDao</span></span><br><span class="line"><span class="meta">@RemoteProxy(creator = SpringCreator.class,</span></span><br><span class="line"><span class="meta">    creatorParams = @Param(name = &quot;beanName&quot;, value = &quot;bookDao&quot;),</span></span><br><span class="line"><span class="meta">    name=&quot;bookFunctions&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RemoteMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">通过指定<span class="meta">@RemoteProxy</span>中的creator类型为SpringCreator，然后在creatorParams指定对应的beanName名称。对应的dwr.xml文件如下：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE dwr PUBLIC</span><br><span class="line">    <span class="string">&quot;-//GetAhead Limited//DTD Direct Web Remoting 2.0//EN&quot;</span></span><br><span class="line">    <span class="string">&quot;http://getahead.ltd.uk/dwr/dwr20.dtd&quot;</span>&gt;</span><br><span class="line">&lt;dwr&gt;</span><br><span class="line">    &lt;allow&gt;</span><br><span class="line">        &lt;create creator=<span class="string">&quot;spring&quot;</span> javascript=<span class="string">&quot;bookFunctions&quot;</span>&gt;</span><br><span class="line">            &lt;param name=<span class="string">&quot;beanName&quot;</span> value=<span class="string">&quot;bookDao&quot;</span> /&gt;</span><br><span class="line">            &lt;include method=<span class="string">&quot;addBook&quot;</span> /&gt;</span><br><span class="line">        &lt;/create&gt;</span><br><span class="line">    &lt;/allow&gt;</span><br><span class="line">&lt;/dwr&gt;</span><br><span class="line"><span class="number">2.</span> <span class="meta">@DataTransferObject</span>和<span class="meta">@RemoteProperty</span></span><br><span class="line"><span class="meta">@DataTransferObject</span>对应于原来dwr.xml文件中的convert标签，用于转换Java对象；<span class="meta">@RemoteProperty</span>则对应于convert标签中的 &lt;param name=”include” value=”<span class="string">&quot; /&gt;。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">举例说明一下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@DataTransferObject</span></span><br><span class="line"><span class="string">public class Book &#123;</span></span><br><span class="line"><span class="string">    @RemoteProperty</span></span><br><span class="line"><span class="string">    private int id;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @RemoteProperty</span></span><br><span class="line"><span class="string">    private String name;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public Book() &#123;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public int getId() &#123;</span></span><br><span class="line"><span class="string">        return id;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public void setId(int id) &#123;</span></span><br><span class="line"><span class="string">        this.id = id;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public String getName() &#123;</span></span><br><span class="line"><span class="string">        return name;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public void setName(String name) &#123;</span></span><br><span class="line"><span class="string">        this.name = name;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@RemoteProperty可以放在JavaBean中的私有变量上面，也可以放在getXXX方法上面。另外如果想将JavaBean中所有的属性都暴露出来的话，不需要在任何属性上面添加@RemoteProperty注释就可以了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上面的注释对应的dwr.xml文件如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!DOCTYPE dwr PUBLIC</span></span><br><span class="line"><span class="string">    &quot;</span>-<span class="comment">//GetAhead Limited//DTD Direct Web Remoting 2.0//EN&quot;</span></span><br><span class="line">    <span class="string">&quot;http://getahead.ltd.uk/dwr/dwr20.dtd&quot;</span>&gt;</span><br><span class="line">&lt;dwr&gt;</span><br><span class="line">    &lt;allow&gt;</span><br><span class="line">        &lt;convert converter=<span class="string">&quot;bean&quot;</span></span><br><span class="line">            match=<span class="string">&quot;com.javatang.domain.Book&quot;</span>&gt;</span><br><span class="line">            &lt;param name=<span class="string">&quot;include&quot;</span> value=<span class="string">&quot;id, name&quot;</span> /&gt;</span><br><span class="line">        &lt;/convert&gt;</span><br><span class="line">        &lt;!-- 或者用下面的方式也可以</span><br><span class="line">        &lt;convert converter=<span class="string">&quot;bean&quot;</span> match=<span class="string">&quot;com.javatang.domain.Book&quot;</span> /&gt;</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;/allow&gt;</span><br><span class="line">&lt;/dwr&gt;</span><br><span class="line">关于具体每个注释使用的方法已经所包含的参数可以参考Java Doc。使用DWR2<span class="number">.0</span>的注解极大的简化了原来dwr.xml的配置，非常的方便。</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/18/Java/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%92%8C%E5%B7%A5%E5%85%B7/dwr%E4%BD%BF%E7%94%A8js%E8%B0%83%E7%94%A8java%E6%96%B9%E6%B3%95/" data-id="ckk2gq3tv001gz8pq367j04o7" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java/开发框架和工具/Drtools业务规则引擎" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/18/Java/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%92%8C%E5%B7%A5%E5%85%B7/Drtools%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/" class="article-date">
  <time class="dt-published" datetime="2021-01-18T11:01:37.395Z" itemprop="datePublished">2021-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/18/Java/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E5%92%8C%E5%B7%A5%E5%85%B7/Drtools%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/" data-id="ckk2gq3tu001fz8pqayda7646" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java/使用easypoi实现excel上传" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/18/Java/%E4%BD%BF%E7%94%A8easypoi%E5%AE%9E%E7%8E%B0excel%E4%B8%8A%E4%BC%A0/" class="article-date">
  <time class="dt-published" datetime="2021-01-18T11:01:37.392Z" itemprop="datePublished">2021-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/18/Java/%E4%BD%BF%E7%94%A8easypoi%E5%AE%9E%E7%8E%B0excel%E4%B8%8A%E4%BC%A0/" data-id="ckk2gq3st0000z8pq5w6z6xgi" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java/jvm虚拟机" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/18/Java/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="article-date">
  <time class="dt-published" datetime="2021-01-18T11:01:37.390Z" itemprop="datePublished">2021-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>2万字长文包教包会 JVM 内存结构   保姆级学习笔记 - 贾不假的文章 - 知乎 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/161777331">https://zhuanlan.zhihu.com/p/161777331</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/18/Java/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/" data-id="ckk2gq3t8000az8pq5w44hj95" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java/java线程池" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/18/Java/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="article-date">
  <time class="dt-published" datetime="2021-01-18T11:01:37.388Z" itemprop="datePublished">2021-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池，首先我们从最核心的ThreadPoolExecutor类中的方法讲起，然后再讲述它的实现原理，接着给出了它的使用示例，最后讨论了一下如何合理配置线程池的大小。</p>
<p>以下是本文的目录大纲：</p>
<p>一.Java中的ThreadPoolExecutor类</p>
<p>二.深入剖析线程池实现原理</p>
<p>三.使用示例</p>
<p>四.如何合理配置线程池的大小　</p>
<h4 id="一-Java中的ThreadPoolExecutor类"><a href="#一-Java中的ThreadPoolExecutor类" class="headerlink" title="一.Java中的ThreadPoolExecutor类"></a>一.Java中的ThreadPoolExecutor类</h4><p>java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。</p>
<p>在ThreadPoolExecutor类中提供了四个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</p>
<p>下面解释下一下构造器中各个参数的含义：</p>
<ul>
<li><p>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</p>
</li>
<li><p>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</p>
</li>
<li><p>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</p>
</li>
<li><p>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure>
<p>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br></pre></td></tr></table></figure>
<p>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p>
<ul>
<li>threadFactory：线程工厂，主要用来创建线程；</li>
<li>handler：表示当拒绝处理任务时的策略，有以下四种取值：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>
<p>具体参数的配置与线程池的关系将在下一节讲述。</p>
<p>从上面给出的ThreadPoolExecutor类的代码可以知道，ThreadPoolExecutor继承了AbstractExecutorService，我们来看一下AbstractExecutorService的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。</p>
<p>我们接着看ExecutorService接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而ExecutorService又是继承了Executor接口，我们看一下Executor接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，大家应该明白了ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor几个之间的关系了。</p>
<p>Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；</p>
<p>然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；</p>
<p>抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；</p>
<p>然后ThreadPoolExecutor继承了类AbstractExecutorService。</p>
<p>在ThreadPoolExecutor类中有几个非常重要的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execute()</span><br><span class="line">submit()</span><br><span class="line">shutdown()</span><br><span class="line">shutdownNow()</span><br></pre></td></tr></table></figure>
<p>execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p>
<p>submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。</p>
<p>shutdown()和shutdownNow()是用来关闭线程池的。</p>
<p>还有很多其他的方法：</p>
<p>比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法，可以查阅API。</p>
<h4 id="二-深入剖析线程池实现原理"><a href="#二-深入剖析线程池实现原理" class="headerlink" title="二.深入剖析线程池实现原理"></a>二.深入剖析线程池实现原理</h4><p>在上一节我们从宏观上介绍了ThreadPoolExecutor，下面我们来深入解析一下线程池的具体实现原理，将从下面几个方面讲解：</p>
<p>　　<strong>1.线程池状态</strong></p>
<p>　　<strong>2.任务的执行</strong></p>
<p>　　<strong>3.线程池中的线程初始化</strong></p>
<p>　　<strong>4.任务缓存队列及排队策略</strong></p>
<p>　　<strong>5.任务拒绝策略</strong></p>
<p>　　<strong>6.线程池的关闭</strong></p>
<p>　　<strong>7.线程池容量的动态调整</strong></p>
<p><strong>1.线程池状态</strong></p>
<p>　　在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p> 　runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；</p>
<p>　　下面的几个static final变量表示runState可能的几个取值。</p>
<p>　　当创建线程池后，初始时，线程池处于RUNNING状态；</p>
<p>　　如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</p>
<p>　　如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</p>
<p>　　当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</p>
<p><strong>2.任务的执行</strong></p>
<p>　　在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;              <span class="comment">//任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();   <span class="comment">//线程池的主要状态锁，对线程池状态（比如线程池大小</span></span><br><span class="line">                                                              <span class="comment">//、runState等）的改变都要使用这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();  <span class="comment">//用来存放工作集</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>  keepAliveTime;    <span class="comment">//线程存货时间   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   corePoolSize;     <span class="comment">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   maximumPoolSize;   <span class="comment">//线程池最大能容忍的线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   poolSize;       <span class="comment">//线程池中当前的线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler; <span class="comment">//任务拒绝策略</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;   <span class="comment">//线程工厂，用来创建线程</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;   <span class="comment">//用来记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   <span class="comment">//用来记录已经执行完毕的任务个数</span></span><br></pre></td></tr></table></figure>
<p> 　每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。</p>
<p>　　corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：</p>
<p>　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p>
<p>　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p>
<p>　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p>
<p>　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p>
<p>　　然后就将任务也分配给这4个临时工人做；</p>
<p>　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p>
<p>　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p>
<p>　　这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。</p>
<p>　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p>
<p>　　不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。</p>
<p>　　largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。</p>
<p>　　下面我们进入正题，看一下任务从提交到最终执行完毕经历了哪些过程。</p>
<p>　　在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　上面的代码可能看起来不是那么容易理解，下面我们一句一句解释：</p>
<p>　　首先，判断提交的任务command是否为null，若是null，则抛出空指针异常；</p>
<p>　　接着是这句，这句要好好理解一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if&#96; &#96;(poolSize &gt;&#x3D; corePoolSize || !addIfUnderCorePoolSize(command))</span><br></pre></td></tr></table></figure>
<p> 　由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的if语句块了。</p>
<p>　　如果线程池中当前线程数小于核心池大小，则接着执行后半部分，也就是执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addIfUnderCorePoolSize(command)</span><br></pre></td></tr></table></figure>
<p>　　如果执行完addIfUnderCorePoolSize这个方法返回false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了。</p>
<p>　　如果执行完addIfUnderCorePoolSize这个方法返回false，然后接着判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if&#96; &#96;(runState &#x3D;&#x3D; RUNNING &amp;&amp; workQueue.offer(command))</span><br></pre></td></tr></table></figure>
<p> 　如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addIfUnderMaximumPoolSize(command)</span><br></pre></td></tr></table></figure>
<p>　　如果执行addIfUnderMaximumPoolSize方法失败，则执行reject()方法进行任务拒绝处理。</p>
<p>　　回到前面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if&#96; &#96;(runState &#x3D;&#x3D; RUNNING &amp;&amp; workQueue.offer(command))</span><br></pre></td></tr></table></figure>
<p> 　这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if&#96; &#96;(runState !&#x3D; RUNNING || poolSize &#x3D;&#x3D; &#96;&#96;0&#96;&#96;)</span><br></pre></td></tr></table></figure>
<p> 　这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施。如果是这样就执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ensureQueuedTaskHandled(command)</span><br></pre></td></tr></table></figure>
<p> 　进行应急处理，从名字可以看出是保证 添加到任务缓存队列中的任务得到处理。</p>
<p>　　我们接着看2个关键方法的实现：addIfUnderCorePoolSize和addIfUnderMaximumPoolSize：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private boolean addIfUnderCorePoolSize(Runnable firstTask) &#123;</span><br><span class="line">    Thread t &#x3D; null;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (poolSize &lt; corePoolSize &amp;&amp; runState &#x3D;&#x3D; RUNNING)</span><br><span class="line">            t &#x3D; addThread(firstTask);        &#x2F;&#x2F;创建线程去执行firstTask任务   </span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (t &#x3D;&#x3D; null)</span><br><span class="line">        return false;</span><br><span class="line">    t.start();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　这个是addIfUnderCorePoolSize方法的具体实现，从名字可以看出它的意图就是当低于核心吃大小时执行的方法。下面看其具体实现，首先获取到锁，因为这地方涉及到线程池状态的变化，先通过if语句判断当前线程池中的线程数目是否小于核心池大小，有朋友也许会有疑问：前面在execute()方法中不是已经判断过了吗，只有线程池当前线程数目小于核心池大小才会执行addIfUnderCorePoolSize方法的，为何这地方还要继续判断？原因很简单，前面的判断过程中并没有加锁，因此可能在execute方法判断的时候poolSize小于corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致poolSize不小于corePoolSize了，所以需要在这个地方继续判断。然后接着判断线程池的状态是否为RUNNING，原因也很简单，因为有可能在其他线程中调用了shutdown或者shutdownNow方法。然后就是执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t &#x3D; addThread(firstTask);</span><br></pre></td></tr></table></figure>
<p> 　这个方法也非常关键，传进去的参数为提交的任务，返回值为Thread类型。然后接着在下面判断t是否为空，为空则表明创建线程失败（即poolSize&gt;=corePoolSize或者runState不等于RUNNING），否则调用t.start()方法启动线程。</p>
<p>　　我们来看一下addThread方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Thread addThread(Runnable firstTask) &#123;</span><br><span class="line">    Worker w &#x3D; new Worker(firstTask);</span><br><span class="line">    Thread t &#x3D; threadFactory.newThread(w);  &#x2F;&#x2F;创建一个线程，执行任务   </span><br><span class="line">    if (t !&#x3D; null) &#123;</span><br><span class="line">        w.thread &#x3D; t;            &#x2F;&#x2F;将创建的线程的引用赋值为w的成员变量       </span><br><span class="line">        workers.add(w);</span><br><span class="line">        int nt &#x3D; ++poolSize;     &#x2F;&#x2F;当前线程数加1       </span><br><span class="line">        if (nt &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize &#x3D; nt;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　在addThread方法中，首先用提交的任务创建了一个Worker对象，然后调用线程工厂threadFactory创建了一个新的线程t，然后将线程t的引用赋值给了Worker对象的成员变量thread，接着通过workers.add(w)将Worker对象添加到工作集当中。</p>
<p>　　下面我们看一下Worker类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock runLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Runnable firstTask;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">    Thread thread;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runLock.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock runLock = <span class="keyword">this</span>.runLock;</span><br><span class="line">        <span class="keyword">if</span> (runLock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != Thread.currentThread())</span><br><span class="line">        thread.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                runLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock runLock = <span class="keyword">this</span>.runLock;</span><br><span class="line">        runLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState &lt; STOP &amp;&amp;</span><br><span class="line">                Thread.interrupted() &amp;&amp;</span><br><span class="line">                runState &gt;= STOP)</span><br><span class="line">            <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">            beforeExecute(thread, task);   <span class="comment">//beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据</span></span><br><span class="line">            <span class="comment">//自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等           </span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                task.run();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">                afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                ++completedTasks;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ran)</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            runLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable task = firstTask;</span><br><span class="line">            firstTask = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                runTask(task);</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerDone(<span class="keyword">this</span>);   <span class="comment">//当任务队列中没有任务时，进行清理工作       </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　它实际上实现了Runnable接口，因此上面的Thread t = threadFactory.newThread(w);效果跟下面这句的效果基本一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t &#x3D; &#96;&#96;new&#96; &#96;Thread(w);</span><br></pre></td></tr></table></figure>
<p> 　相当于传进去了一个Runnable任务，在线程t中执行这个Runnable。</p>
<p>　　既然Worker实现了Runnable接口，那么自然最核心的方法便是run()方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runTask(task);</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　从run方法的实现可以看出，它首先执行的是通过构造器传进来的任务firstTask，在调用runTask()执行完firstTask之后，在while循环里面不断通过getTask()去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取，getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> state = runState;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; SHUTDOWN)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Runnable r;</span><br><span class="line">            <span class="keyword">if</span> (state == SHUTDOWN)  <span class="comment">// Help drain queue</span></span><br><span class="line">                r = workQueue.poll();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) <span class="comment">//如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，</span></span><br><span class="line">                <span class="comment">//则通过poll取任务，若等待一定的时间取不到任务，则返回null</span></span><br><span class="line">                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">if</span> (workerCanExit()) &#123;    <span class="comment">//如果没取到任务，即r为null，则判断当前的worker是否可以退出</span></span><br><span class="line">                <span class="keyword">if</span> (runState &gt;= SHUTDOWN) <span class="comment">// Wake up others</span></span><br><span class="line">                    interruptIdleWorkers();   <span class="comment">//中断处于空闲状态的worker</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Else retry</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            <span class="comment">// On interruption, re-check runState</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　在getTask中，先判断当前线程池状态，如果runState大于SHUTDOWN（即为STOP或者TERMINATED），则直接返回null。</p>
<p>　　如果runState为SHUTDOWN或者RUNNING，则从任务缓存队列取任务。</p>
<p>　　如果当前线程池的线程数大于核心池大小corePoolSize或者允许为核心池中的线程设置空闲存活时间，则调用poll(time,timeUnit)来取任务，这个方法会等待一定的时间，如果取不到任务就返回null。</p>
<p>　　然后判断取到的任务r是否为null，为null则通过调用workerCanExit()方法来判断当前worker是否可以退出，我们看一下workerCanExit()的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">workerCanExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">boolean</span> canExit;</span><br><span class="line">    <span class="comment">//如果runState大于等于STOP，或者任务缓存队列为空了</span></span><br><span class="line">    <span class="comment">//或者  允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        canExit = runState &gt;= STOP ||</span><br><span class="line">            workQueue.isEmpty() ||</span><br><span class="line">            (allowCoreThreadTimeOut &amp;&amp;</span><br><span class="line">             poolSize &gt; Math.max(<span class="number">1</span>, corePoolSize));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canExit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　也就是说如果线程池处于STOP状态、或者任务队列已为空或者允许为核心池线程设置空闲存活时间并且线程数大于1时，允许worker退出。如果允许worker退出，则调用interruptIdleWorkers()中断处于空闲状态的worker，我们看一下interruptIdleWorkers()的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)  <span class="comment">//实际上调用的是worker的interruptIfIdle()方法</span></span><br><span class="line">            w.interruptIfIdle();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　从实现可以看出，它实际上调用的是worker的interruptIfIdle()方法，在worker的interruptIfIdle()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock runLock = <span class="keyword">this</span>.runLock;</span><br><span class="line">    <span class="keyword">if</span> (runLock.tryLock()) &#123;    <span class="comment">//注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的</span></span><br><span class="line">                                <span class="comment">//如果成功获取了锁，说明当前worker处于空闲状态</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != Thread.currentThread())  </span><br><span class="line">    thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            runLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　　这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。</p>
<p> 　我们再看addIfUnderMaximumPoolSize方法的实现，这个方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderMaximumPoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; maximumPoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　看到没有，其实它和addIfUnderCorePoolSize方法的实现基本一模一样，只是if语句判断条件中的poolSize &lt; maximumPoolSize不同而已。</p>
<p>　　到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：</p>
<p>　　1）首先，要清楚corePoolSize和maximumPoolSize的含义；</p>
<p>　　2）其次，要知道Worker是用来起到什么作用的；</p>
<p>　　3）要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</p>
<ul>
<li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li>
<li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li>
</ul>
<p><strong>3.线程池中的线程初始化</strong></p>
<p>　　默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p>
<p>　　在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p>
<ul>
<li>prestartCoreThread()：初始化一个核心线程；</li>
<li>prestartAllCoreThreads()：初始化所有核心线程</li>
</ul>
<p>　　下面是这2个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addIfUnderCorePoolSize(<span class="keyword">null</span>); <span class="comment">//注意传进去的参数是null</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addIfUnderCorePoolSize(<span class="keyword">null</span>))<span class="comment">//注意传进去的参数是null</span></span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r &#x3D; workQueue.take();</span><br></pre></td></tr></table></figure>
<p> 　即等待任务队列中有任务。</p>
<p><strong>4.任务缓存队列及排队策略</strong></p>
<p>　　在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。</p>
<p>　　workQueue的类型为BlockingQueue<Runnable>，通常可以取下面三种类型：</p>
<p>　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p>
<p>　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p>
<p>　　3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p>
<p><strong>5.任务拒绝策略</strong></p>
<p>　　当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>
<p><strong>6.线程池的关闭</strong></p>
<p>　　ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p>
<ul>
<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
<p><strong>7.线程池容量的动态调整</strong></p>
<p>　　ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，</p>
<ul>
<li>setCorePoolSize：设置核心池大小</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小</li>
</ul>
<p>　　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</p>
<h4 id="三-使用示例"><a href="#三-使用示例" class="headerlink" title="三.使用示例"></a>三.使用示例</h4><p>前面我们讨论了关于线程池的实现原理，这一节我们来看一下它的具体使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">         ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                 <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">             MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line">             executor.execute(myTask);</span><br><span class="line">             System.out.println(<span class="string">&quot;线程池中线程数目：&quot;</span>+executor.getPoolSize()+<span class="string">&quot;，队列中等待执行的任务数目：&quot;</span>+</span><br><span class="line">             executor.getQueue().size()+<span class="string">&quot;，已执行玩别的任务数目：&quot;</span>+executor.getCompletedTaskCount());</span><br><span class="line">         &#125;</span><br><span class="line">         executor.shutdown();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskNum = num;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行task &quot;</span>+taskNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;task &quot;</span>+taskNum+<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">正在执行task <span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">1</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">1</span></span><br><span class="line">线程池中线程数目：<span class="number">3</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">2</span></span><br><span class="line">线程池中线程数目：<span class="number">4</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">3</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">4</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">2</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">3</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">4</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">6</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">10</span></span><br><span class="line">线程池中线程数目：<span class="number">7</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">11</span></span><br><span class="line">线程池中线程数目：<span class="number">8</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">12</span></span><br><span class="line">线程池中线程数目：<span class="number">9</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">13</span></span><br><span class="line">线程池中线程数目：<span class="number">10</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">14</span></span><br><span class="line">task <span class="number">3</span>执行完毕</span><br><span class="line">task <span class="number">0</span>执行完毕</span><br><span class="line">task <span class="number">2</span>执行完毕</span><br><span class="line">task <span class="number">1</span>执行完毕</span><br><span class="line">正在执行task <span class="number">8</span></span><br><span class="line">正在执行task <span class="number">7</span></span><br><span class="line">正在执行task <span class="number">6</span></span><br><span class="line">正在执行task <span class="number">5</span></span><br><span class="line">task <span class="number">4</span>执行完毕</span><br><span class="line">task <span class="number">10</span>执行完毕</span><br><span class="line">task <span class="number">11</span>执行完毕</span><br><span class="line">task <span class="number">13</span>执行完毕</span><br><span class="line">task <span class="number">12</span>执行完毕</span><br><span class="line">正在执行task <span class="number">9</span></span><br><span class="line">task <span class="number">14</span>执行完毕</span><br><span class="line">task <span class="number">8</span>执行完毕</span><br><span class="line">task <span class="number">5</span>执行完毕</span><br><span class="line">task <span class="number">7</span>执行完毕</span><br><span class="line">task <span class="number">6</span>执行完毕</span><br><span class="line">task <span class="number">9</span>执行完毕</span><br></pre></td></tr></table></figure>


<p>　　从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。</p>
<p>　　不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool();        &#x2F;&#x2F;创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span><br><span class="line">Executors.newSingleThreadExecutor();   &#x2F;&#x2F;创建容量为1的缓冲池</span><br><span class="line">Executors.newFixedThreadPool(int);    &#x2F;&#x2F;创建固定容量大小的缓冲池</span><br></pre></td></tr></table></figure>
<p> 　下面是这三个静态方法的具体实现;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。</p>
<p>　　newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；</p>
<p>　　newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；</p>
<p>　　newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p>
<p>　　实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。</p>
<p>　　另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。</p>
<h4 id="四-如何合理配置线程池的大小"><a href="#四-如何合理配置线程池的大小" class="headerlink" title="四.如何合理配置线程池的大小"></a>四.如何合理配置线程池的大小</h4><p>本节来讨论一个比较重要的话题：如何合理配置线程池大小，仅供参考。</p>
<p>一般需要根据任务的类型来配置线程池大小：</p>
<p>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 <em>N</em>CPU+1</p>
<p>如果是IO密集型任务，参考值可以设置为2*<em>N</em>CPU</p>
<p>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/18/Java/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" data-id="ckk2gq3uh001pz8pq1beybgns" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java/java的设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/18/Java/java%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-01-18T11:01:37.386Z" itemprop="datePublished">2021-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>适配器模式:使用适配器模式连接原本不支持某接口的具体实现,如slf4j和log4j的适配器</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/18/Java/java%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="ckk2gq3t70009z8pqey6m37wd" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java/java基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/18/Java/java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-01-18T11:01:37.384Z" itemprop="datePublished">2021-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>java后台启动jar包</p>
<p>nohup java -jar dataportal.jar &gt; log.txt 2&gt;&amp;1 &amp;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/18/Java/java%E5%9F%BA%E7%A1%80/" data-id="ckk2gq3t70008z8pq2my29w7s" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IDE/Intellij Idea/IDea的debug模式详细使用说明" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/18/IDE/Intellij%20Idea/IDea%E7%9A%84debug%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" class="article-date">
  <time class="dt-published" datetime="2021-01-18T11:01:37.272Z" itemprop="datePublished">2021-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="IDEA中如何使用debug调试项目"><a href="#IDEA中如何使用debug调试项目" class="headerlink" title="IDEA中如何使用debug调试项目"></a>IDEA中如何使用debug调试项目</h3><p>Debug用来追踪代码的运行流程，通常在程序运行过程中出现异常，启用Debug模式可以分析定位异常发生的位置，以及在运行过程中参数的变化。通常我们也可以启用Debug模式来跟踪代码的运行流程去学习三方框架的源码。</p>
<p>　　所以学习下如何在Intellij IDEA中使用好Debug，主要包括如下内容：</p>
<p>　　　　一、Debug开篇</p>
<p>　　　　二、基本用法&amp;快捷键</p>
<p>　　　　三、变量查看</p>
<p>　　　　四、计算表达式</p>
<p>　　　　五、智能步入</p>
<p>　　　　六、断点条件设置</p>
<p>　　　　七、多线程调试</p>
<p>　　　　八、回退断点</p>
<p>　　　　九、中断Debug</p>
<p>　　　　十、附：JRebel激活</p>
<h4 id="一、Debug开篇"><a href="#一、Debug开篇" class="headerlink" title="一、Debug开篇"></a>一、Debug开篇</h4><p>　　首先看下IDEA中Debug模式下的界面。</p>
<p>　　如下是在IDEA中启动Debug模式，进入断点后的界面，我这里是Windows，可能和Mac的图标等会有些不一样。就简单说下图中标注的8个地方：</p>
<p>　　① 以Debug模式启动服务，左边的一个按钮则是以Run模式启动。在开发中，我一般会直接启动Debug模式，方便随时调试代码。</p>
<p>　　② 断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上/取消断点，断点行的颜色可自己去设置。</p>
<p>　　③ Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置，如图1.2。</p>
<p>　　④ 调试按钮：一共有8个按钮，调试的主要功能就对应着这几个按钮，鼠标悬停在按钮上可以查看对应的快捷键。在菜单栏Run里可以找到同样的对应的功能，如图1.4。</p>
<p>　　⑤ 服务按钮：可以在这里关闭/启动服务，设置断点等。</p>
<p>　　⑥ 方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的[Show All Frames]按钮，就不会显示其它类库的方法了，否则这里会有一大堆的方法。</p>
<p>　　⑦ Variables：在变量区可以查看当前断点之前的当前方法内的变量。</p>
<p>　　⑧ Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 </p>
<p>　　[图1.1]</p>
<p><img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210110235114.png" alt="img"></p>
<p> 　[图1.2]：在设置里勾选Show debug window on breakpoint，则请求进入到断点后自动激活Debug窗口</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111095351.png" alt="img"></p>
<p>　　[图1.3]：如果你的IDEA底部没有显示工具栏或状态栏，可以在View里打开，显示出工具栏会方便我们使用。可以自己去尝试下这四个选项。</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111095411.png" alt="img"></p>
<p>　　[图1.4]：在菜单栏Run里有调试对应的功能，同时可以查看对应的快捷键。</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111095421.png" alt="img"></p>
<h4 id="二、基本用法-amp-快捷键"><a href="#二、基本用法-amp-快捷键" class="headerlink" title="二、基本用法&amp;快捷键"></a>二、基本用法&amp;快捷键</h4><p>Debug调试的功能主要对应着图一中4和5两组按钮：</p>
<p>　　1、首先说第一组按钮，共8个按钮，从左到右依次如下：</p>
<p>　　　　 [图2.1]</p>
<p><img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102033.png" alt="img"></p>
<p>　　　　&gt; Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。</p>
<p>　　　　&gt; Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</p>
<p>　　　　&gt; Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。</p>
<p>　　　　&gt; Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</p>
<p>　　　　&gt; Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</p>
<p>　　　　&gt; Drop Frame (默认无)：回退断点，后面章节详细说明。</p>
<p>　　　　&gt; Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</p>
<p>　　　　&gt; Evaluate Expression (Alt + F8)：计算表达式，后面章节详细说明。</p>
<p>　　2、第二组按钮，共7个按钮，从上到下依次如下：</p>
<p> 　　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102041.png" alt="img"></p>
<p> [图2.2]</p>
<p>　　　　&gt; Rerun ‘xxxx’：重新运行程序，会关闭服务后重新启动程序。</p>
<p>　　　　&gt; Update ‘tech’ application (Ctrl + F5)：更新程序，一般在你的代码有改动后可执行这个功能。而这个功能对应的操作则是在服务配置里，如图2.3。</p>
<p>　　　　&gt; Resume Program (F9)：恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按F9，则运行到下一个断点(即第25行)，再按F9，则运行完整个流程，因为后面已经没有断点了。</p>
<p>　　　　&gt; Pause Program：暂停程序，启用Debug。目前没发现具体用法。</p>
<p>　　　　&gt; Stop ‘xxx’ (Ctrl + F2)：连续按两下，关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了。</p>
<p>　　　　&gt; View Breakpoints (Ctrl + Shift + F8)：查看所有断点，后面章节会涉及到。</p>
<p>　　　　&gt; Mute Breakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled，如图2.4，则该行断点失效。</p>
<p>　　　　 [图2.3]：更新程序，On ‘Update’ actions，执行更新操作时所做的事情，一般选择’Update classes and resources’，即更新类和资源文件。</p>
<p>　　　　　　　一般配合热部署插件会更好用，如JRebel，这样就不用每次更改代码后还要去重新启动服务。如何激活JRebel，在最后章节附上。</p>
<p>　　　　　　　下面的On frame deactivation，在IDEA窗口失去焦点时触发，即一般你从idea切换到浏览器的时候，idea会自动帮你做的事情，一般可以设置Do nothing，频繁切换会比较消耗资源的。</p>
<p> 　 　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102045.png" alt="img"></p>
<p>　　　　[图2.4]　</p>
<p> <img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102153.png" alt="img"></p>
<h4 id="三、变量查看"><a href="#三、变量查看" class="headerlink" title="三、变量查看"></a><strong>三、变量查看</strong></h4><p>在Debug过程中，跟踪查看变量的变化是非常必要的，这里就简单说下IDEA中可以查看变量的几个地方，相信大部分人都了解。</p>
<p>　　1、如下，在IDEA中，参数所在行后面会显示当前变量的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102052.png" alt="img"></p>
<p>　　 [图3.1]</p>
<p>　　2、光标悬停到参数上，显示当前变量信息。点击打开详情如图3.3。我一般会使用这种方式，快捷方便。</p>
<p>　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102054.png" alt="img"></p>
<p>　 [图3.2]</p>
<p><img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102128.png" alt="956249-20190704110137835-1811308941"></p>
<p> [图3.3]</p>
<p>　　3、在Variables里查看，这里显示当前方法里的所有变量。</p>
<p> 　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102213.png" alt="img"></p>
<p> [图3.4]</p>
<p>　　4、在Watches里，点击New Watch，输入需要查看的变量。或者可以从Variables里拖到Watche里查看。</p>
<p>　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102218.png" alt="img"></p>
<p>　 [图3.5]</p>
<p>　　如果你发现你没有Watches，可能在下图所在的地方。</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102226.png" alt="img"></p>
<p> [图3.6] </p>
<p>　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102234.png" alt="img"></p>
<p>  [图3.7]</p>
<h4 id="四、计算表达式"><a href="#四、计算表达式" class="headerlink" title="四、计算表达式"></a>四、计算表达式</h4><p>　　在前面提到的计算表达式如图4.1的按钮，Evaluate Expression (Alt + F8) 。可以使用这个操作在调试过程中计算某个表达式的值，而不用再去打印信息。</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102241.png" alt="img"></p>
<p> [图4.1]</p>
<p>　　1、按Alt + F8或按钮，或者，你可以选中某个表达式再Alt + F8，弹出计算表达式的窗口，如下，回车或点击Evaluate计算表达式的值。</p>
<p>　　　 这个表达式不仅可以是一般变量或参数，也可以是方法，当你的一行代码中调用了几个方法时，就可以通过这种方式查看查看某个方法的返回值。</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102249.png" alt="img"></p>
<p> [图4.2]</p>
<p>　　2、设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了不是。</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102258.png" alt="img"></p>
<p> [图4.3]</p>
<h4 id="五、智能步入"><a href="#五、智能步入" class="headerlink" title="五、智能步入"></a>五、智能步入</h4><p>　　想想，一行代码里有好几个方法，怎么只选择某一个方法进入。之前提到过使用Step Into (Alt + F7) 或者 Force Step Into (Alt + Shift + F7)进入到方法内部，但这两个操作会根据方法调用顺序依次进入，这比较麻烦。</p>
<p>　　那么智能步入就很方便了，智能步入，这个功能在Run里可以看到，Smart Step Into (Shift + F7)，如图5.1</p>
<p>　　 <img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102306.png" alt="img"></p>
<p>[图5.1]</p>
<p>　　按Shift + F7，会自动定位到当前断点行，并列出需要进入的方法，如图5.2，点击方法进入方法内部。</p>
<p>　　如果只有一个方法，则直接进入，类似Force Step Into。</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102314.png" alt="img"></p>
<p> [图5.2]</p>
<h4 id="六、断点条件设置"><a href="#六、断点条件设置" class="headerlink" title="六、断点条件设置"></a>六、断点条件设置</h4><p>　　通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</p>
<p>　　通常，当我们在遍历一个比较大的集合或数组时，在循环内设置了一个断点，难道我们要一个一个去看变量的值？那肯定很累，说不定你还错过这个值得重新来一次。</p>
<p>　　1、在断点上右键直接设置当前断点的条件，如图6.1，我设置exist为true时断点才生效。</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102322.png" alt="img"></p>
<p> [图6.1]</p>
<p>　　2、点击View Breakpoints (Ctrl + Shift + F8)，查看所有断点。</p>
<p>　　　　Java Line Breakpoints 显示了所有的断点，在右边勾选Condition，设置断点的条件。</p>
<p>　　　　勾选Log message to console，则会将当前断点行输出到控制台，如图6.3</p>
<p>　　　　勾选Evaluate and log，可以在执行这行代码是计算表达式的值，并将结果输出到控制台。</p>
<p>　　 [图6.2]</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102331.png" alt="img"></p>
<p>　　 [图6.3]</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102341.png" alt="img"></p>
<p>　　3、再说说右边的Filters过滤，这些一般情况下不常用，简单说下意思。</p>
<p>　　　　Instance filters：实例过滤，输入实例ID(如图6.5中的实例ID)，但是我这里没有成功，不知道什么原因，知道的朋友留个言。</p>
<p>　　　　Class filters：类过滤，根据类名过滤，同样没有成功….</p>
<p>　　　　Pass count：用于循环中，如果断点在循环中，可以设置该值，循环多少次后停在断点处，之后的循环都会停在断点处。</p>
<p>　　[图6.4]</p>
<p>　　 <img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102351.png" alt="img"></p>
<p>　　 [图6.5]</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102401.png" alt="img"></p>
<p>　　4、异常断点，通过设置异常断点，在程序中出现需要拦截的异常时，会自动定位到异常行。</p>
<p>　　如图6.6，点击+号添加Java Exception Breakpoints，添加异常断点。然后输入需要断点的异常类，如图6.7，之后可以在Java Exception Breakpoints里看到添加的异常断点。</p>
<p>　　我这里添加了一个NullPointerException异常断点，如图6.8，出现空指针异常后，自动定位在空指针异常行。</p>
<p> 　[图6.6]</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102412.png" alt="img"></p>
<p>　　[图6.7]</p>
<p>　　 <img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102420.png" alt="img"></p>
<p>　　[图6.8]</p>
<p>　　 </p>
<p> <img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102427.png" alt="img"></p>
<h4 id="七、多线程调试"><a href="#七、多线程调试" class="headerlink" title="七、多线程调试"></a>七、多线程调试</h4><p>　　一般情况下我们调试的时候是在一个线程中的，一步一步往下走。但有时候你会发现在Debug的时候，想发起另外一个请求都无法进行了？</p>
<p>　　那是因为IDEA在Debug时默认阻塞级别是ALL，会阻塞其它线程，只有在当前调试线程走完时才会走其它线程。可以在View Breakpoints里选择Thread，如图7.1，然后点击Make Default设置为默认选项。</p>
<p>　　[图7.1]</p>
<p>　　 <img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102435.png" alt="img"></p>
<p>　　切换线程，在图7.2中Frames的下拉列表里，可以切换当前的线程，如下我这里有两个Debug的线程，切换另外一个则进入另一个Debug的线程。</p>
<p>　　[图7.2]</p>
<p>　　 <img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102444.png" alt="img"></p>
<h4 id="八、回退断点"><a href="#八、回退断点" class="headerlink" title="八、回退断点"></a>八、回退断点</h4><p>　　在调试的时候，想要重新走一下流程而不用再次发起一个请求？</p>
<p>　　1、首先认识下这个方法调用栈，如图8.1，首先请求进入DemoController的insertDemo方法，然后调用insert方法，其它的invoke我们且先不管，最上面的方法是当前断点所在的方法。</p>
<p>　　[图8.1]</p>
<p>　　 <img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102454.png" alt="img"></p>
<p>　　2、断点回退</p>
<p>　　所谓的断点回退，其实就是回退到上一个方法调用的开始处，在IDEA里测试无法一行一行地回退或回到到上一个断点处，而是回到上一个方法。</p>
<p>　　回退的方式有两种，一种是Drop Frame按钮(图8.2)，按调用的方法逐步回退，包括三方类库的其它方法(取消Show All Frames按钮会显示三方类库的方法，如图8.3)。</p>
<p>　　第二种方式，在调用栈方法上选择要回退的方法，右键选择Drop Frame(图8.4)，回退到该方法的上一个方法调用处，此时再按F9(Resume Program)，可以看到程序进入到该方法的断点处了。</p>
<p>　　但有一点需要注意，断点回退只能重新走一下流程，之前的某些参数/数据的状态已经改变了的是无法回退到之前的状态的，如对象、集合、更新了数据库数据等等。</p>
<p>　　图[8.2]</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102506.png" alt="img"></p>
<p>　　图[8.3]</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102512.png" alt="img"></p>
<p>　　图[8.4]</p>
<p>　　</p>
<p> <img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102520.png" alt="img"></p>
<h4 id="九、中断Debug"><a href="#九、中断Debug" class="headerlink" title="九、中断Debug"></a>九、中断Debug</h4><p>　　想要在Debug的时候，中断请求，不要再走剩余的流程了？</p>
<p>　　有些时候，我们看到传入的参数有误后，不想走后面的流程了，怎么中断这次请求呢(后面的流程要删除数据库数据呢….)，难道要关闭服务重新启动程序？嗯，我以前也是这么干的。</p>
<p>　　确切的说，我也没发现可以直接中断请求的方式(除了关闭服务)，但可以通过Force Return，即强制返回来避免后续的流程，如图9.1。</p>
<p>　　点击Force Return，弹出Return Value的窗口，我这个方法的返回类型为Map，所以，我这里直接返回 results，来强制返回，从而不再进行后续的流程。或者你可以new HashMap&lt;&gt;()。</p>
<p>　　[图9.1]</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102526.png" alt="img"></p>
<p>　　[图9.2]</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/20210111102534.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/18/IDE/Intellij%20Idea/IDea%E7%9A%84debug%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" data-id="ckk2gq3uf001oz8pqhsoc6zko" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IDE/Intellij Idea/idea快捷命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/18/IDE/Intellij%20Idea/idea%E5%BF%AB%E6%8D%B7%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2021-01-18T11:01:37.270Z" itemprop="datePublished">2021-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Ctrl+Alt+[        跳转上一个项目</p>
<p>Ctrl+Alt+]        跳转下一个项目</p>
<p>Ctrl+Shift+A      查看快捷键</p>
<p>Ctrl+E          查看最近操作文件</p>
<p>Alt+Shift+C        查看最近修改文件</p>
<p>Ctrl+Shift+退格      跳转最近修改位置</p>
<p>Ctrl+Alt+左方向      跳转最近查看位置</p>
<p>Shift+F11        添加标签</p>
<p>Alt+Shift+F        添加类或函数到收藏</p>
<p>Ctrl+N          搜索类,再按一次可搜索非项目的类</p>
<p>Ctrl+Shift+N      搜索文件,再按一次可搜索非项目的文件</p>
<p>Ctrl+Shift+Alt+N    搜索符号，包括属性和方法名,再按一次可搜索非项目的符号</p>
<p>Ctrl+Shift+F      搜索字符串</p>
<p>annotate        行数边框右键点击annotate可以查看git/svn信息</p>
<p>Ctrl+Alt+Shift+上下箭头  修改内容移动</p>
<p>Ctrl+Alt+Z        撤销修改，在文件夹上使用可以撤销文件夹下所有修改</p>
<p>Ctrl+y     删除当前行</p>
<p>Ctrl+/     生成注释</p>
<p>Ctrl+D    idea中选中两个文件，使用该快捷键可比对两个文件</p>
<p>Alt+insert  生成get和set方法</p>
<p>Ctrl+Shift+/  注释</p>
<p>Alt+enter    快速自动补全返回对象,可以自动生成接口方法</p>
<p>POM文件中鼠标右键点击Disgrams,选择show dependencies可以查看依赖视图</p>
<p>Ctrl+G可以快速跳转位置</p>
<p>Ctrl+o    添加接口的实现方法</p>
<p>Ctrl+F9    重新编译</p>
<p>Ctrl+h    查看接口的实现类</p>
<p>Alt+F7    或方法上鼠标右键find Usages</p>
<p>Ctrl+D    idea复制当前行代码到下一行</p>
<p>shift+enter    直接切换到下一行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/18/IDE/Intellij%20Idea/idea%E5%BF%AB%E6%8D%B7%E5%91%BD%E4%BB%A4/" data-id="ckk2gq3tu001ez8pq7sch4b2j" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IDE/Intellij Idea/idea常用配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/18/IDE/Intellij%20Idea/idea%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2021-01-18T11:01:37.268Z" itemprop="datePublished">2021-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>File-&gt;New-&gt;Module From Exsisting Projects-&gt;选择项目导入</li>
</ol>
<ol start="2">
<li>Maven工程没有对应的Maven标准目录时，需手动创建， idea 2020.1版本中创建resources目录直接创建为资源目录</li>
</ol>
<ol start="3">
<li>如果不是先创建resources右键-&gt;mark directory as -&gt; resources root</li>
</ol>
<ol start="4">
<li><p>在运行构建好的maven新文件中出现以下报错（当时就复制了这个搜索错误）</p>
<p>Error:(3, 24) java: 程序包org.junit不存在</p>
</li>
</ol>
<ol start="5">
<li>打开project structure-&gt;libraries-&gt;java-&gt;然后寻找idea的安装目录下的lib，我直接全部导入了然后再次运行app.java就没有报错了</li>
</ol>
<ol start="6">
<li>File-&gt;Project Structure-&gt;Modules-&gt;工程名-&gt;web-&gt;Web Resource Directories 修改允许创建web资源的目录</li>
</ol>
<ol start="7">
<li>新建了一个maven web项目。然后我新建了一个java文件夹，里面加了一个包，无法在这个包里直接选择创建servlet，解决方法：File-&gt;Project Structure-&gt;Modules-&gt;工程名-&gt;web-&gt;选中source roots为src\main\java，重启项目或者Idea即可</li>
</ol>
<ol start="8">
<li>IntelliJ IDEA 2020.1破解方法：安装完成后进入30天免费使用后，将jetbrains-agent.jar文件拖入到Idea界面选择安装激活，重启Idea即可破解</li>
</ol>
<ol start="9">
<li>Idea中添加tomcat服务器：Edit Configurations-&gt;Tomcat Server-&gt;Local</li>
</ol>
<ol start="10">
<li><p>设置包层级结构，点击做窗口</p>
<p><img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/%E5%8C%85%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.png"></p>
</li>
</ol>
<ol start="11">
<li>Idea设置properties文件编码为utf-8,File-&gt;Editor-&gt;File Encodings-&gt;Propertes Files选中默认编码为utf-8,并勾选自动转换为ascii![](D:\Typora\file\常用命令\Intellij Idea\设置propertoies编码.png)</li>
</ol>
<ol start="12">
<li>Idea设置properties文件编码为utf-8,File-&gt;Editor-&gt;File Encodings-&gt;Propertes Files选中默认编码为utf-8,并勾选自动转换为ascii</li>
</ol>
<ol start="13">
<li>Project Structure-&gt;Project Settings-&gt;Modules-&gt;Web Resource Directories-&gt;双击路径，选择路径，点击ok创建webapp，Deployment Descriptors-&gt;Type窗口中点击+创建web.xml</li>
</ol>
<ol start="14">
<li>运行窗口选择Edit Configurations-&gt;点击+号</li>
</ol>
<ol start="15">
<li>File-&gt;Settings-&gt;Version Control-&gt;Git中Path to Git executable选择git bash软件路径下cmd文件夹的git.exe文件</li>
</ol>
<ol start="16">
<li>IntelliJ IDEA如何设置新建类时，自动注释作者信息和日期时间，File–&gt; Settings–&gt; Editor–&gt; File and Code Templates–&gt; Includes–&gt; File Header–&gt; “添加以下代码”</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> $&#123;USER&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> $&#123;DATE&#125; $&#123;TIME&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<p>17    IntelliJ IDEA配置方法自动注释：</p>
<p>​    打开<code>setting -&gt; Editor -&gt; Live Templates -&gt; 点击右边加号添加一个Templates Group -&gt; 然后选中添加的Group再次点击加号添加Live Templates</code>，添加的group名称可以自己决定，但是添加的live templates 名称最好为    *</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">* create by: 杨晋宝</span><br><span class="line">* description: TODO</span><br><span class="line">* create time: $date$ $time$</span><br><span class="line">* @params</span><br><span class="line"><span class="meta">$</span><span class="bash">params$</span></span><br><span class="line">* @return $return$</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line"> params的Exception内容如下：</span><br><span class="line">groovyScript(&quot;def result=&#x27;&#x27;; def params=\&quot;$&#123;_1&#125;\&quot;.replaceAll(&#x27;[\\\\[|\\\\]|\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&#x27;* @&#x27;+&#x27;Param: &#x27; + params[i] + ((i &lt; params.size() - 1) ? &#x27;\\n&#x27; : &#x27;&#x27;)&#125;; return result&quot;, methodParameters())</span><br></pre></td></tr></table></figure>
<p>​    ==注意：自动生成注解时必须使用/*+设置的模板名称，再按Tab键，否则读取不到方法参数和返回值==</p>
<p>​    18.安装IntelliJ IDEA中的lombok插件</p>
<p>​        1）打开IntelliJ IDEA后点击菜单栏中的File–&gt;Settings–&gt;Plugins，或者使用快捷键Ctrl+Alt+S进入到设置页面</p>
<p>​        2）搜索页面输入lombok变可以查询到下方的Lombok Plugin，鼠标点击Lombok Plugin点击Install按钮便可安装，不点Restart按钮重启idea</p>
<p>​        3）在Settings设置页面，我们点击Build，Execution，Deployment–&gt;选择Compiler–&gt;选中Annotation Processors，然后在右侧勾选Enable annotation processing，重启idea</p>
<p>20.Idea运行项目是报错Command line is too long解决方法：</p>
<p>​    将 Configuration 中的 Shorten Command Line 修改为 JAR 就可以了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/FateCause/typoraPic/images/p66104217.webp" alt="img"></p>
<p>21.Idea2020.1.1整合maven有bug，已经导入jar包但是运行报错找不到，根本解决方法：</p>
<p>​        1）删除maven的配置文件settings.xml中修改的本地仓库位置，使用默认配置</p>
<p>​        2）如果需要修改本地仓库位置，可以直接修改Idea中maven的配置即可</p>
<p>​        3）删除报错的jar包重新maven引入</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/18/IDE/Intellij%20Idea/idea%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/" data-id="ckk2gq3tt001dz8pqaua97dzd" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/18/%E4%BA%91%E8%AE%A1%E7%AE%97/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/01/18/%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/03_Redis%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/01/18/%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/02_RabbitMQ%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/01/18/%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/01_%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/01/18/%E5%85%B6%E4%BB%96%E5%B0%8F%E6%8A%80%E5%B7%A7/github%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>